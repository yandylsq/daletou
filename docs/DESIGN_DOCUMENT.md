# å¤§ä¹é€é¢„æµ‹ç³»ç»Ÿ - ç³»ç»Ÿè®¾è®¡æ–‡æ¡£

## æ–‡æ¡£ç‰ˆæœ¬
- **ç‰ˆæœ¬å·**: V1.0
- **æœ€åæ›´æ–°**: 2026-01-21
- **ç»´æŠ¤è€…**: AI Assistant

---

## ğŸ“‹ ç›®å½•
1. [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
2. [æŠ€æœ¯é€‰å‹](#æŠ€æœ¯é€‰å‹)
3. [æ ¸å¿ƒç®—æ³•è®¾è®¡](#æ ¸å¿ƒç®—æ³•è®¾è®¡)
4. [æ•°æ®æµç¨‹](#æ•°æ®æµç¨‹)
5. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
6. [å®‰å…¨æ€§è®¾è®¡](#å®‰å…¨æ€§è®¾è®¡)

---

## ç³»ç»Ÿæ¶æ„

### æ€»ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å‰ç«¯å±‚ (Frontend)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ é¢„æµ‹ç•Œé¢ â”‚  â”‚ å›æµ‹ç•Œé¢ â”‚  â”‚ å†å²æŸ¥è¯¢ â”‚  â”‚ å¯¼å‡ºåŠŸèƒ½ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”˜
        â”‚             â”‚             â”‚             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ HTTP/SSE
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 API ç½‘å…³å±‚ (Flask)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚     app.py (è·¯ç”±æ§åˆ¶ + SSE æµå¼å“åº”)      â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ä¸šåŠ¡é€»è¾‘å±‚ (Business)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ DaletouPredictor â”‚  â”‚  ModelEngine     â”‚             â”‚
â”‚  â”‚   (é¢„æµ‹å¼•æ“)     â”‚  â”‚  (æ¨¡å‹ç®¡ç†)      â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚           â”‚                     â”‚                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚      å·ç ç”Ÿæˆ + è¯„åˆ† + è¿‡æ»¤é€»è¾‘        â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 æœºå™¨å­¦ä¹ å±‚ (ML)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Stacking Model â”‚  â”‚ LSTM Model â”‚  â”‚ Graph Modelâ”‚     â”‚
â”‚  â”‚   (é›†æˆå­¦ä¹ )   â”‚  â”‚  (æ—¶åº)    â”‚  â”‚  (ç½‘ç»œ)    â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ•°æ®å±‚ (Data)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ å†å²å¼€å¥–æ•°æ®    â”‚  â”‚  æ¨¡å‹ç¼“å­˜æ–‡ä»¶   â”‚               â”‚
â”‚  â”‚ .txt / .csv     â”‚  â”‚  .pkl / .json   â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### åˆ†å±‚èŒè´£

| å±‚çº§ | èŒè´£ | æŠ€æœ¯ç»„ä»¶ |
|------|------|---------|
| **å‰ç«¯å±‚** | ç”¨æˆ·äº¤äº’ã€ç»“æœå±•ç¤º | HTML + CSS + JavaScript + SSE |
| **APIå±‚** | è·¯ç”±åˆ†å‘ã€æµå¼æ¨é€ | Flask + Server-Sent Events |
| **ä¸šåŠ¡å±‚** | é¢„æµ‹é€»è¾‘ã€è¿‡æ»¤è¯„åˆ† | Python + NumPy + Pandas |
| **MLå±‚** | æ¨¡å‹è®­ç»ƒã€æ¦‚ç‡é¢„æµ‹ | scikit-learn + PyTorch + NetworkX |
| **æ•°æ®å±‚** | æ•°æ®å­˜å‚¨ã€ç¼“å­˜ç®¡ç† | Text Files + Pickle + JSON |

---

## æŠ€æœ¯é€‰å‹

### åç«¯æ¡†æ¶

#### Flask
- **é€‰å‹ç†ç”±**ï¼šè½»é‡çº§ã€æ˜“æ‰©å±•ã€åŸç”Ÿæ”¯æŒ SSE
- **ç‰ˆæœ¬è¦æ±‚**ï¼š>= 2.0
- **æ ¸å¿ƒç‰¹æ€§**ï¼š
  - æ”¯æŒ Generator æµå¼å“åº”
  - CORS è·¨åŸŸæ”¯æŒ
  - ä¸­é—´ä»¶æ‰©å±•èƒ½åŠ›

### æœºå™¨å­¦ä¹ åº“

#### scikit-learn
- **ç”¨é€”**ï¼šStacking å…ƒå­¦ä¹ æ¨¡å‹
- **æ ¸å¿ƒç®—æ³•**ï¼š
  - `RandomForestClassifier`ï¼šéšæœºæ£®æ—åŸºå­¦ä¹ å™¨
  - `GradientBoostingClassifier`ï¼šGBDT åŸºå­¦ä¹ å™¨
  - `LogisticRegression`ï¼šå…ƒå­¦ä¹ å™¨

#### PyTorch
- **ç”¨é€”**ï¼šLSTM æ—¶åºæ¨¡å‹
- **ä¼˜åŠ¿**ï¼š
  - åŠ¨æ€è®¡ç®—å›¾ï¼Œçµæ´»è°ƒè¯•
  - é«˜ç‰ˆæœ¬ Python å…¼å®¹æ€§å¥½
  - ç¤¾åŒºæ´»è·ƒï¼Œæ–‡æ¡£å®Œå–„

> âš ï¸ **å¼ƒç”¨ TensorFlow**ï¼šé«˜ç‰ˆæœ¬ Pythonï¼ˆ3.10+ï¼‰ä¸‹ TensorFlow çš„ LSTM å­˜åœ¨å…¼å®¹æ€§é—®é¢˜

#### NetworkX
- **ç”¨é€”**ï¼šå·ç å…±ç°ç½‘ç»œåˆ†æ
- **æ ¸å¿ƒç®—æ³•**ï¼šPageRankã€åº¦ä¸­å¿ƒæ€§

### æ•°æ®å¤„ç†

#### NumPy
- **ç”¨é€”**ï¼šæ•°å€¼è®¡ç®—ã€çŸ©é˜µè¿ç®—
- **å…³é”®æ“ä½œ**ï¼š
  - éšæœºç§å­è®¾ç½®ï¼ˆç¡®ä¿ç¡®å®šæ€§ï¼‰
  - æ¦‚ç‡é‡‡æ ·ï¼ˆnp.random.choiceï¼‰

#### Pandas
- **ç”¨é€”**ï¼šå†å²æ•°æ®åŠ è½½ã€ç‰¹å¾æå–
- **ä¼˜åŠ¿**ï¼š
  - å¼ºå¤§çš„ DataFrame æ“ä½œ
  - é«˜æ•ˆçš„æ—¶é—´åºåˆ—å¤„ç†

---

## æ ¸å¿ƒç®—æ³•è®¾è®¡

### 1. å…¨é‡æšä¸¾è¯„åˆ†ç®—æ³•

#### è®¾è®¡ç›®æ ‡
- âœ… éå†æ‰€æœ‰åˆæ³•å·ç ç»„åˆ
- âœ… è¾¹æšä¸¾è¾¹è¿‡æ»¤ï¼Œé¿å…å†…å­˜çˆ†ç‚¸
- âœ… æ”¯æŒä»»åŠ¡ä¸­æ­¢ï¼ˆcancel_checkï¼‰

#### ç®—æ³•ä¼ªä»£ç 

```python
def predict_with_full_enumeration(period, filters, cancel_check):
    # 1. åˆå§‹åŒ–ï¼šè®¾ç½®éšæœºç§å­
    np.random.seed(int(period))
    
    # 2. ç”Ÿæˆå…¨é‡ç»„åˆç©ºé—´
    all_red_combos = combinations(available_red, 5)   # C(n,5)
    all_blue_combos = combinations(available_blue, 2) # C(m,2)
    
    # 3. è¾¹æšä¸¾è¾¹è¿‡æ»¤
    scored_combos = []
    for red in all_red_combos:
        if cancel_check():
            break
        
        # 3.1 å‰ç½®è¿‡æ»¤ï¼ˆä»…é¢„æµ‹æ¨¡å¼ï¼‰
        if not is_backtest:
            if violates_basic_rules(red):
                continue
        
        # 3.2 ç”¨æˆ·è¿‡æ»¤ï¼ˆä»…é¢„æµ‹æ¨¡å¼ï¼‰
        if not is_backtest:
            if violates_user_filters(red, filters):
                continue
        
        # 3.3 è“çƒéå†
        for blue in all_blue_combos:
            if cancel_check():
                break
            
            # è“çƒè¿‡æ»¤ï¼ˆä»…é¢„æµ‹æ¨¡å¼ï¼‰
            if not is_backtest:
                if violates_blue_rules(blue, filters):
                    continue
            
            # 3.4 æ·±åº¦è¯„åˆ†
            score = multi_dimensional_scoring(red, blue)
            scored_combos.append({'red': red, 'blue': blue, 'score': score})
    
    # 4. æ’åºå– Top N
    scored_combos.sort(key=lambda x: x['score'], reverse=True)
    
    # 5. å¤šæ ·æ€§è¿‡æ»¤ (MMR)
    final_results = apply_diversity_filter(scored_combos, n=20)
    
    return final_results
```

#### å¤æ‚åº¦åˆ†æ

| é¡¹ç›® | æ•°å€¼ | è¯´æ˜ |
|------|------|------|
| **çº¢çƒç»„åˆæ•°** | C(35,5) = 324,632 | æ— æ€å·æƒ…å†µ |
| **è“çƒç»„åˆæ•°** | C(12,2) = 66 | æ— æ€å·æƒ…å†µ |
| **æ€»ç»„åˆæ•°** | 21,425,712 | ç†è®ºæœ€å¤§å€¼ |
| **å®é™…è¯„åˆ†æ•°** | 2,000,000 - 5,000,000 | ç»è¿‡å‰ç½®è¿‡æ»¤å |
| **æ—¶é—´å¤æ‚åº¦** | O(nÃ—mÃ—k) | n:çº¢çƒ, m:è“çƒ, k:è¯„åˆ† |
| **ç©ºé—´å¤æ‚åº¦** | O(p) | p:é€šè¿‡è¿‡æ»¤çš„ç»„åˆæ•° |

---

### 2. å¤šç»´è¯„åˆ†ç®—æ³•

#### è¯„åˆ†ä½“ç³»æ¶æ„

```
                    æœ€ç»ˆå¾—åˆ†
                       â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚              â”‚              â”‚
    åŸºç¡€å¾—åˆ†       æ¨¡å‹åŠ æˆ        ç½‘é¡µåŠ æˆ
    (100-500åˆ†)   (Ã—1.0-4.25)    (Ã—1.0-1.5)
        â”‚
    â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚        â”‚        â”‚        â”‚        â”‚
  ç»Ÿè®¡ç‰¹å¾  å†å²ç‰¹å¾  å†·çƒ­åˆ†æ  ç¦»æ•£åº¦  è´¨æ•°åˆ†å¸ƒ
```

#### è¯„åˆ†æµç¨‹

```python
def score_combination(red, blue, history, models):
    score = 0
    
    # ==== ç¬¬ä¸€å±‚ï¼šåŸºç¡€ç»Ÿè®¡ç‰¹å¾ ====
    # 1. å’Œå€¼åˆ¤æ–­
    red_sum = sum(red)
    if 85 <= red_sum <= 115:
        score += 120
    elif 70 <= red_sum <= 130:
        score += 60
    
    # 2. å¥‡å¶æ¯”
    odd_count = sum(1 for x in red if x % 2 == 1)
    if odd_count in [2, 3]:
        score += 80
    
    # 3. è·¨åº¦
    span = max(red) - min(red)
    if 22 <= span <= 32:
        score += 100
    
    # 4. è¿å·æƒ©ç½š
    consecutive_pairs = count_consecutive(red)
    if consecutive_pairs >= 2:
        score -= 350
    
    # 5. ACå€¼ï¼ˆç¦»æ•£åº¦ï¼‰
    ac_val = calculate_ac_value(red)
    if ac_val < 4:
        score -= 500
    elif ac_val >= 7:
        score += 150
    
    # 6. 012è·¯å¹³è¡¡
    if is_012_balanced(red):
        score += 150
    
    # 7. è´¨æ•°åˆ†å¸ƒ
    prime_count = count_primes(red)
    if 1 <= prime_count <= 3:
        score += 100
    
    # ==== ç¬¬äºŒå±‚ï¼šå†å²å…³è”ç‰¹å¾ ====
    # 8. é‡å·ç­–ç•¥
    overlap = len(set(red) & set(last_period_red))
    if overlap == 0:
        score += 100  # å…¨æ–°å·
    elif overlap == 1:
        score += 50   # é€‚åº¦é‡å·
    
    # 9. å†·çƒ­å·å¹³è¡¡
    hot_count = count_hot_numbers(red, hot_cold_map)
    if 2 <= hot_count <= 3:
        score += 80
    
    # 10. è“çƒå¤§å°å¹³è¡¡
    blue_small = sum(1 for b in blue if b <= 6)
    if blue_small == 1:  # 1å°1å¤§
        score += 80
    
    # ==== ç¬¬ä¸‰å±‚ï¼šæœºå™¨å­¦ä¹ åŠ æˆ ====
    # 11. Stacking æ¨¡å‹ç½®ä¿¡åº¦
    red_probas = [model.predict_proba(n) for n in red]
    top3_conf = sum(sorted(red_probas, reverse=True)[:3])
    
    if top3_conf > 0.45:
        red_boost = 1.0 + (top3_conf * 5.0)
    elif top3_conf > 0.3:
        red_boost = 1.0 + (top3_conf * 3.0)
    else:
        red_boost = 1.0 + (top3_conf * 1.5)
    
    # 12. LSTM è“çƒé¢„æµ‹
    blue_lstm_conf = lstm_model.predict(blue)
    blue_boost = 1.0 + (blue_lstm_conf * 3.0)
    
    # ==== ç¬¬å››å±‚ï¼šç½‘é¡µå‚è€ƒåŠ æˆ ====
    ref_hits = count_reference_hits(red, reference_numbers)
    if ref_hits >= 2:
        ref_boost = 1.0 + (ref_hits * 0.1)
    else:
        ref_boost = 1.0
    
    # ==== æœ€ç»ˆå¾—åˆ†è®¡ç®— ====
    final_score = score * red_boost * blue_boost * ref_boost
    
    return final_score
```

---

### 3. å¤šæ ·æ€§è¿‡æ»¤ç®—æ³•ï¼ˆMMRï¼‰

#### è®¾è®¡ç›®æ ‡
é¿å…è¾“å‡ºçš„ Top 20 ç»„åˆè¿‡äºç›¸ä¼¼ï¼ˆå¦‚å‰åŒºç›¸åŒ4ä¸ªå·ï¼‰ã€‚

#### ç®—æ³•æµç¨‹

```python
def apply_diversity_filter(scored_combos, n=20, threshold=4):
    """
    Maximum Marginal Relevance (MMR) å¤šæ ·æ€§è¿‡æ»¤
    
    Args:
        scored_combos: å·²æŒ‰åˆ†æ•°æ’åºçš„ç»„åˆåˆ—è¡¨
        n: æœ€ç»ˆè¾“å‡ºæ•°é‡
        threshold: ç›¸ä¼¼åº¦é˜ˆå€¼ï¼ˆé‡å å·ç æ•°ï¼‰
    
    Returns:
        å¤šæ ·åŒ–çš„ Top N ç»„åˆ
    """
    final_results = []
    
    for combo in scored_combos:
        if len(final_results) >= n:
            break
        
        # æ£€æŸ¥ä¸å·²é€‰ç»„åˆçš„ç›¸ä¼¼åº¦
        is_too_similar = False
        for selected in final_results:
            overlap = len(set(combo['red']) & set(selected['red']))
            if overlap >= threshold:
                is_too_similar = True
                break
        
        # ä¸ç›¸ä¼¼åˆ™åŠ å…¥ç»“æœé›†
        if not is_too_similar:
            final_results.append(combo)
    
    # å¦‚æœä¸å¤Ÿ n ä¸ªï¼Œè¡¥å……é«˜åˆ†ç»„åˆ
    if len(final_results) < n:
        for combo in scored_combos:
            if len(final_results) >= n:
                break
            if combo not in final_results:
                final_results.append(combo)
    
    return final_results
```

---

### 4. ç¡®å®šæ€§ä¿è¯æœºåˆ¶

#### è®¾è®¡åŸåˆ™
**ç›¸åŒè¾“å…¥ â†’ ç›¸åŒè¾“å‡º**ï¼šå¯¹äºåŒä¸€æœŸå·ï¼Œæ— è®ºé¢„æµ‹å¤šå°‘æ¬¡ï¼Œç»“æœå¿…é¡»ä¸€è‡´ã€‚

#### å®ç°æ–¹å¼

```python
def predict(period, ...):
    # åŸºäºæœŸå·è®¾ç½®éšæœºç§å­
    seed = int(period)  # ä¾‹å¦‚ï¼š26009
    np.random.seed(seed)
    random.seed(seed)
    
    # ç¡®ä¿æ‰€æœ‰éšæœºæ“ä½œéƒ½åŸºäºç›¸åŒçš„ç§å­
    # 1. æ¨¡å‹è®­ç»ƒæ—¶çš„éšæœºåˆå§‹åŒ–
    # 2. è¯„åˆ†æ—¶çš„å¾®å°æ‰°åŠ¨
    # 3. å¤šæ ·æ€§è¿‡æ»¤æ—¶çš„éšæœºé‡‡æ ·
```

#### éªŒè¯æ–¹æ³•

```bash
# è¿ç»­é¢„æµ‹åŒä¸€æœŸå·3æ¬¡
python test_determinism.py 26009

# é¢„æœŸè¾“å‡º
[âœ“] Run 1: Top 1 = [03, 12, 19, 28, 34] + [02, 09]
[âœ“] Run 2: Top 1 = [03, 12, 19, 28, 34] + [02, 09]
[âœ“] Run 3: Top 1 = [03, 12, 19, 28, 34] + [02, 09]
[âœ“] ç¡®å®šæ€§æµ‹è¯•é€šè¿‡ï¼
```

---

## æ•°æ®æµç¨‹

### é¢„æµ‹æµç¨‹å®Œæ•´æ•°æ®æµ

```
ç”¨æˆ·è¯·æ±‚
  â”‚
  â”œâ”€ æœŸå·: "26009"
  â”œâ”€ æ€å·: [1, 2, 35]
  â”œâ”€ å’Œå€¼: [80, 120]
  â””â”€ å‚è€ƒç½‘é¡µ: ["https://..."]
  â”‚
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. å‚æ•°é¢„å¤„ç†       â”‚
â”‚  - è®¾ç½®éšæœºç§å­      â”‚
â”‚  - åŠ è½½å†å²æ•°æ®      â”‚
â”‚  - è®¡ç®—å†·çƒ­å·ç»Ÿè®¡    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. ç½‘é¡µåˆ†æ         â”‚
â”‚  - æå–æ¨èå·ç       â”‚
â”‚  - ç»Ÿè®¡å·ç é¢‘ç‡      â”‚
â”‚  - è®¡ç®—æƒé‡          â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. ç»„åˆæšä¸¾         â”‚
â”‚  - çº¢çƒ: C(32,5)     â”‚
â”‚  - è“çƒ: C(12,2)     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. å‰ç½®è¿‡æ»¤         â”‚
â”‚  â”œâ”€ å†å²å¼€å¥–å·ç      â”‚
â”‚  â”œâ”€ å››è¿å·           â”‚
â”‚  â”œâ”€ ç­‰å·®/ç­‰æ¯”æ•°åˆ—    â”‚
â”‚  â”œâ”€ å…¨å¥‡/å…¨å¶        â”‚
â”‚  â””â”€ åŒåŒºå·ç          â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ (å‰©ä½™ 45%)
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. ç”¨æˆ·è¿‡æ»¤         â”‚
â”‚  â”œâ”€ å’Œå€¼èŒƒå›´         â”‚
â”‚  â”œâ”€ å¥‡å¶æ¯”           â”‚
â”‚  â”œâ”€ å‰åŒºé‡å· â‰¥3      â”‚
â”‚  â””â”€ ååŒºé‡å· â‰¥2      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ (å‰©ä½™ 35%)
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  6. æ·±åº¦è¯„åˆ†         â”‚
â”‚  â”œâ”€ ç»Ÿè®¡ç‰¹å¾è¯„åˆ†     â”‚
â”‚  â”œâ”€ å†å²ç‰¹å¾è¯„åˆ†     â”‚
â”‚  â”œâ”€ æ¨¡å‹ç½®ä¿¡åº¦åŠ æˆ   â”‚
â”‚  â””â”€ ç½‘é¡µå‚è€ƒåŠ æˆ     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  7. æ’åºå– Top 100   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  8. å¤šæ ·æ€§è¿‡æ»¤(MMR)  â”‚
â”‚  - é¿å…é‡å  â‰¥4 å·    â”‚
â”‚  - è¾“å‡º Top 20       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  9. ç”Ÿæˆé€‰å·ç†ç”±     â”‚
â”‚  - å’Œå€¼åŒºé—´          â”‚
â”‚  - é‡å·æƒ…å†µ          â”‚
â”‚  - æ¨¡å‹ç½®ä¿¡åº¦        â”‚
â”‚  - è“çƒç­–ç•¥          â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  10. SSE æµå¼è¾“å‡º    â”‚
â”‚  - æ¯ç§’æ¨é€ 1-2 æ¡   â”‚
â”‚  - å‰ç«¯å®æ—¶æ˜¾ç¤º      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. ç‰¹å¾è®¡ç®—ç¼“å­˜

#### é—®é¢˜
æ¯æ¬¡è¯„åˆ†éƒ½é‡æ–°è®¡ç®—å†å²ç‰¹å¾ï¼Œå¯¼è‡´æ€§èƒ½ä½ä¸‹ã€‚

#### è§£å†³æ–¹æ¡ˆ
```python
class DaletouPredictor:
    def __init__(self):
        self._cached_feat = None
        self._cached_moms = None
    
    def extract_features(self, df, last_only=True):
        # æ£€æŸ¥ç¼“å­˜
        if self._cached_feat is not None and last_only:
            return self._cached_feat
        
        # è®¡ç®—ç‰¹å¾
        features = self._compute_features(df)
        
        # æ›´æ–°ç¼“å­˜
        if last_only:
            self._cached_feat = features
        
        return features
```

**ä¼˜åŒ–æ•ˆæœ**ï¼šç‰¹å¾æå–æ—¶é—´ä» `500ms` é™è‡³ `5ms`ã€‚

---

### 2. æ¨¡å‹é¢„æµ‹æ‰¹é‡åŒ–

#### é—®é¢˜
é€ä¸ªå·ç è°ƒç”¨æ¨¡å‹é¢„æµ‹ï¼Œå¯¼è‡´é¢‘ç¹çš„æ¨¡å‹åŠ è½½ã€‚

#### è§£å†³æ–¹æ¡ˆ
```python
def _predict_with_stacking(self, features, target_type='red'):
    # æ‰¹é‡é¢„æµ‹æ‰€æœ‰å·ç 
    all_numbers = range(1, 36) if target_type == 'red' else range(1, 13)
    probas = {}
    
    for num in all_numbers:
        # ä¸€æ¬¡æ€§è·å–æ‰€æœ‰æ¦‚ç‡
        prob = self.stacking_meta_model[num].predict_proba([features])[0][1]
        probas[num] = prob
    
    return probas
```

**ä¼˜åŒ–æ•ˆæœ**ï¼šæ¨¡å‹é¢„æµ‹æ—¶é—´ä» `2000ms` é™è‡³ `300ms`ã€‚

---

### 3. è¾¹æšä¸¾è¾¹è¿‡æ»¤

#### é—®é¢˜
å…ˆç”Ÿæˆæ‰€æœ‰ç»„åˆå†è¿‡æ»¤ï¼Œå†…å­˜å ç”¨é«˜è¾¾ 10GB+ã€‚

#### è§£å†³æ–¹æ¡ˆ
```python
# âŒ é”™è¯¯æ–¹å¼ï¼šå…ˆç”Ÿæˆæ‰€æœ‰ç»„åˆ
all_combos = list(combinations(range(1, 36), 5))  # å†…å­˜çˆ†ç‚¸
filtered = [c for c in all_combos if is_valid(c)]

# âœ… æ­£ç¡®æ–¹å¼ï¼šè¾¹æšä¸¾è¾¹è¿‡æ»¤
for combo in combinations(range(1, 36), 5):
    if not is_valid(combo):
        continue
    scored_combos.append(score(combo))
```

**ä¼˜åŒ–æ•ˆæœ**ï¼šå†…å­˜å ç”¨ä» `10GB` é™è‡³ `500MB`ã€‚

---

### 4. æµå¼è¾“å‡ºä¼˜åŒ–

#### è®¾è®¡æ€è·¯
ä¸ç­‰æ‰€æœ‰ç»“æœè®¡ç®—å®Œæˆï¼Œè¾¹è®¡ç®—è¾¹æ¨é€ã€‚

#### å®ç°æ–¹å¼
```python
@app.route('/api/predict', methods=['POST'])
def predict_api():
    def generate():
        for i, result in enumerate(model.predict(...)):
            # æ¯è®¡ç®—å‡º1ä¸ªç»“æœç«‹å³æ¨é€
            yield f"data: {json.dumps(result)}\n\n"
            time.sleep(0.5)  # æ§åˆ¶æ¨é€é¢‘ç‡
    
    return Response(generate(), mimetype='text/event-stream')
```

**ç”¨æˆ·ä½“éªŒæå‡**ï¼šä»ç­‰å¾… 30 ç§’çœ‹åˆ°ç»“æœ â†’ æ¯ç§’çœ‹åˆ° 1-2 ä¸ªç»“æœè·³åŠ¨æ˜¾ç¤ºã€‚

---

## å®‰å…¨æ€§è®¾è®¡

### 1. è¾“å…¥éªŒè¯

```python
def validate_input(data):
    # æœŸå·æ ¼å¼æ ¡éªŒ
    if not re.match(r'^\d{5}$', data['period']):
        raise ValueError("æœŸå·æ ¼å¼é”™è¯¯")
    
    # æ€å·èŒƒå›´æ ¡éªŒ
    if data.get('kill_red'):
        if not all(1 <= n <= 35 for n in data['kill_red']):
            raise ValueError("çº¢çƒæ€å·è¶…å‡ºèŒƒå›´")
    
    # å’Œå€¼èŒƒå›´æ ¡éªŒ
    if data.get('sum_range'):
        if not (25 <= data['sum_range'][0] <= data['sum_range'][1] <= 175):
            raise ValueError("å’Œå€¼èŒƒå›´ä¸åˆç†")
```

---

### 2. å¼‚å¸¸æ•è·ä¸é™çº§

```python
def predict_with_fallback(period, ...):
    try:
        # å°è¯•å®Œæ•´é¢„æµ‹æµç¨‹
        return full_prediction(period, ...)
    except ModelNotTrained:
        # é™çº§ï¼šä»…ä½¿ç”¨ç»Ÿè®¡ç‰¹å¾è¯„åˆ†
        return statistical_prediction(period, ...)
    except OutOfMemory:
        # é™çº§ï¼šå‡å°‘å€™é€‰ç»„åˆæ•°
        return light_prediction(period, max_combos=100000)
    except Exception as e:
        # å…œåº•ï¼šè¿”å›éšæœºç»„åˆ
        logger.error(f"é¢„æµ‹å¤±è´¥: {e}")
        return random_prediction(period, n=20)
```

---

### 3. ä»»åŠ¡ä¸­æ­¢æœºåˆ¶

```python
# å…¨å±€ä»»åŠ¡çŠ¶æ€ç®¡ç†
task_status = {}

def predict_with_cancel(task_id, period, ...):
    def cancel_check():
        return task_status.get(task_id, {}).get('cancelled', False)
    
    for combo in enumerate_combinations(...):
        # æ¯æ¬¡å¾ªç¯æ£€æŸ¥æ˜¯å¦å–æ¶ˆ
        if cancel_check():
            logger.info(f"ä»»åŠ¡ {task_id} å·²å–æ¶ˆ")
            break
        
        # ç»§ç»­è®¡ç®—
        score = evaluate(combo)
```

---

## é™„å½•

### å…³é”®ä»£ç æ–‡ä»¶æ¸…å•

| æ–‡ä»¶ | è¡Œæ•° | èŒè´£ |
|------|------|------|
| `app.py` | 300+ | Flask è·¯ç”±ã€SSE æµå¼å“åº” |
| `model_engine.py` | 1800+ | é¢„æµ‹å¼•æ“ã€è¯„åˆ†é€»è¾‘ã€è¿‡æ»¤æ¡ä»¶ |
| `daletou_history_full.txt` | 1000+ | å†å²å¼€å¥–æ•°æ® |

### æŠ€æœ¯å€ºåŠ¡

| é—®é¢˜ | ä¼˜å…ˆçº§ | è®¡åˆ’è§£å†³æ—¶é—´ |
|------|--------|-------------|
| LSTMæ¨¡å‹å‡†ç¡®ç‡åä½ | P1 | V2.0 |
| ç½‘é¡µåˆ†ææˆåŠŸç‡ä¸ç¨³å®š | P2 | V1.5 |
| ç¼ºå°‘å•å…ƒæµ‹è¯•è¦†ç›– | P2 | V1.5 |

### æ›´æ–°æ—¥å¿—

| ç‰ˆæœ¬ | æ—¥æœŸ | æ›´æ–°å†…å®¹ |
|------|------|---------|
| V1.0 | 2026-01-21 | åˆå§‹ç‰ˆæœ¬ï¼Œå®Œæ•´ç³»ç»Ÿè®¾è®¡æ–‡æ¡£ |

---

**æ–‡æ¡£ç»“æŸ**
