---
trigger: manual
---

# 查找接口需求规范 v1.1
# ============================================
# AI 辅助查找表关联接口的规则和要求
# 采用双向递归查找表关联接口时严格遵循这些规则
#
# 使用方法：
# 1. 将此文件放在项目根目录
# 2. 在 AI 对话中使用 @search-interface.txt 引用
# 3. AI 将自动遵循这些规则
#
# 适用范围：所有编程语言和框架
# 最后更新：2025-12-16
# ============================================

## [规则 1] 正相关联查找所有使用表A的接口和方法
# 查找完全，不能遗漏

- 查找表A自身的 DAO/Service/API 方法

❌ 错误：
1、当表A通过join关联其他表时，不需要查找其他表的接口，例如 A LEFT JOIN T，此时不需要查找T的接口和方法，如果T是通过JPA注解关联表A才需要找表T的接口方法
2、当其他表通过join关联表A时，不需要查找其他表的接口，例如 T LEFT JOIN A，此时不需要查找T的接口和方法，如果T是通过JPA注解关联表A才需要找表T的接口方法
3、当表A实体类通过JPA注解关联其他表时，不需要查找其他表的接口，只有其他表实体类通过JPA注解关联表A时，才需要找其他表的接口方法。例如，表A实体类中通过@ManyToOne关联表H，此时不需要找表H的接口方法。

## [规则 2] 反向查找引用表A的所有表的接口和方法
# 查找完全，不能遗漏

- 查找所有通过JPA注解引用表A的表，例如表B、表C等，找到所有使用表B、表C等表的所有接口和方法，包括正向关联（规则 1）和反向关联（规则 2）->递归查找

注意：不包含表B、表C和其他表join关联的sql，比如有个sql只有表B或者表C和表F关联，没有涉及表A，这时候这个sql对应的接口方法不需要查找

❌ 错误：
1、如果表B通过JPA注解关联了表A，此时有个sql join是表B和表F关联，例如 B LEFT JOIN F，没有涉及到表A，这个sql对应的接口方法不需要查找，否则查找出来的方法没有使用到表A，会多查出这个方法来。
2、当表B实体类通过JPA注解关联其他表时，不需要查找其他表的接口，只有其他表实体类通过JPA注解关联表B时，才需要找其他表的接口方法。例如，表B实体类中通过@ManyToOne关联表K，此时不需要找表K的接口方法。
3、当表B通过join关联其他表时，不需要查找其他表的接口，例如 B LEFT JOIN O，此时不需要查找O的接口和方法，如果O是通过JPA注解关联表B才需要找表O的接口方法
4、当其他表通过join关联表B时，不需要查找其他表的接口，例如 O LEFT JOIN B，此时不需要查找O的接口和方法，如果O是通过JPA注解关联表B才需要找表O的接口方法



## [规则 3] 在规则 2的基础上，继续反向查找引用表B、表C等表的所有表的接口和方法
# 查找完全，不能遗漏

- 在规则 2的基础上继续查找所有通过JPA注解引用表B、表C等表的所有表，例如表D、表E等表，找到所有使用表D、表E等表的所有接口和方法，包括正向关联（规则 1）和反向关联（规则 2）->递归查找

注意：不包含表D、表E和其他表join关联的sql，比如有个sql只有表D或者表E和表F关联，没有涉及表A，这时候这个接口方法不需要查找

❌ 错误：
同规则 1、规则2的错误


## [规则 4] 持续递归
# 查找完全，不能遗漏

- 持续递归查找，直到没有新的关联表为止

❌ 错误：
同规则 1、规则2的错误


## [规则 5] 从之前的错误中学习（优先级：高）
# 不要重复对话历史中的错误

- 实现前参考对话历史
- 避免犯同样的错误两次
- 记住用户反馈和偏好

## [规则 6] 第一次就完全修复错误（优先级：高）
# 解决根本原因，而不是症状

- 提供可工作的修复，而不是迭代尝试
- 解决根本原因，而不仅仅是症状


## [规则 7] 严格遵循提供的示例（优先级：中）
# 当给出示例时，精确匹配它们


## [规则 8] 验证完整性（优先级：高）
# 解决遗漏接口方法

- 检查所有相关的 Service 实现类
- 检查所有相关的 API 接口
- 交叉验证是否有遗漏
- 对每个使用表的方法，反向追踪所有调用
- 注意公共方法，通常被多个API接口使用，注意间接调用
- 搜索深度需要更加充分，需要查找到最后一层
- 需要更加系统的查找策略，要有调用链反向追踪和完整性验证

## [规则 9] 使用列表展示出来（优先级：高）
# 当查找到所有接口和方法时，在最后必须使用列表显示出全部满足条件的接口和方法，列表展示只要opcnet-api组件中API和方法，不需要service层和dao层。列表只需要展示三列：接口、方法、描述。其中描述的内容只有三种，分别是：单表查询、JOIN关联、JPA关联。
# 单表查询：接口使用到的表有且只有提问中的表，例如表A
# JOIN关联：接口使用到多张表，包含提问中的表，并且提问中的表跟其他表只通过JOIN关联，例如表B通过JOIN关联表A，或者表A通过JOIN关联表B
# JPA关联：其他表通过JPA注解关联提问中的表，例如表B实体类中通过@OneToMany关联表A



# ============================================
# 摘要 - 关键规则（最高优先级）
# ============================================

举个例子：如果让查找所有使用表A的api和方法，需要找出所有使用到表A的api和方法，但是如果表B通过JPA 注解关联（例如@OneToMany, @ManyToOne, @OneToOne, @ManyToMany）关联表A，则也需要找出所有表B使用到的api和方法，注意不包含表B和其他表join关联的sql，比如有个sql只有表B和表F关联，没有涉及表A，这时候这个接口方法不需要查找。并且需要进一步查找是否有其他表通过JPA 注解关联（例如@OneToMany, @ManyToOne, @OneToOne, @ManyToMany）关联表B，或者通过sql关联表B，比如表C通过JPA关联表C，则也需要找出所有使用到表C的api和方法。并且再进一步查找所有关联C的，再超找所有关联D.....重复递归查找，直到找出所有api和方法。

完整查找流程
查找表 A 的所有 API 和方法：

第 1 层：表 A
├── A 自身的 DAO/Service/API 方法
└── A 的 SQL JOIN 的 SQL方法

第 2 层：反向查找引用 A 的表
├── 表 B 通过 @OneToMany 引用 A
│   ├── B 自身的所有 API 和方法，注意不包含表B和其他表join关联的sql，比如有个sql只有表B和表F关联，没有涉及表A，这时候这个接口方法不需要查找 ✅
│   └── B 的 SQL JOIN 表A的SQL，注意不包含表B和其他表join关联的sql，比如有个sql只有表B和表F关联，没有涉及表A，这时候这个接口方法不需要查找 → 递归


第 3 层：查找引用 B 的表
├── 表 D 通过 @ManyToOne 引用 B
│   ├── D 自身的所有 API 和方法，注意不包含表D和其他表join关联的sql，比如有个sql只有表D和表F关联，没有涉及表A，这时候这个接口方法不需要查找 ✅
│   └── D 的 SQL JOIN 表A的SQL，注意不包含表D和其他表join关联的sql，比如有个sql只有表D和表F关联，没有涉及表A，这时候这个接口方法不需要查找 → 递归
│   └── 继续递归查找通过JPA注解引用 D 的表

第 N 层：持续递归
└── 直到没有新的关联表为止


# ============================================
# 版本历史
# ============================================
# v1.1 (2025-12-16) - AI 辅助查找表关联接口的规则和要求
# ============================================
